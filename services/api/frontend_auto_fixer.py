#!/usr/bin/env python3
"""
ÂâçÁ´ØËá™Âä®‰øÆÂ§çËÑöÊú¨
Ëá™Âä®‰øÆÂ§çÂâçÁ´Ø‰ª£Á†Å‰∏≠ÁöÑÂ∏∏ËßÅÈóÆÈ¢ò
"""

import re
import json
from pathlib import Path
import shutil
from datetime import datetime

class FrontendAutoFixer:
    def __init__(self):
        self.frontend_path = Path("../web-admin/src")
        self.fixes_applied = []
        self.backup_dir = Path("frontend_backups") / datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Ê£ÄÊü•ÂâçÁ´ØË∑ØÂæÑÊòØÂê¶Â≠òÂú®
        if not self.frontend_path.exists():
            print(f"‚ùå ÂâçÁ´ØË∑ØÂæÑ‰∏çÂ≠òÂú®: {self.frontend_path.absolute()}")
            print("ËØ∑Á°Æ‰øùÂú®Ê≠£Á°ÆÁöÑÁõÆÂΩï‰∏≠ËøêË°åÊ≠§ËÑöÊú¨")
            exit(1)
        
    def backup_file(self, file_path):
        """Â§á‰ªΩÊñá‰ª∂"""
        if not self.backup_dir.exists():
            self.backup_dir.mkdir(parents=True)
        
        backup_path = self.backup_dir / file_path.relative_to(self.frontend_path)
        backup_path.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(file_path, backup_path)
        print(f"üìÅ Â∑≤Â§á‰ªΩ: {file_path}")
        
    def fix_api_data_access(self, file_path):
        """‰øÆÂ§çAPIÊï∞ÊçÆËÆøÈóÆÈóÆÈ¢ò"""
        content = file_path.read_text(encoding='utf-8')
        original_content = content
        fixes = []
        
        # ‰øÆÂ§ç response.data.voices ‰∏∫ response.voices
        pattern1 = r'response\.data\?\.voices'
        if re.search(pattern1, content):
            content = re.sub(pattern1, 'response.voices', content)
            fixes.append("‰øÆÂ§ç: response.data?.voices -> response.voices")
        
        # ‰øÆÂ§ç response.data?.engines ‰∏∫ response.engines  
        pattern2 = r'response\.data\?\.engines'
        if re.search(pattern2, content):
            content = re.sub(pattern2, 'response.engines', content)
            fixes.append("‰øÆÂ§ç: response.data?.engines -> response.engines")
            
        # ‰øÆÂ§ç response.data.data ‰∏∫ response.data
        pattern3 = r'response\.data\.data'
        if re.search(pattern3, content):
            content = re.sub(pattern3, 'response.data', content)
            fixes.append("‰øÆÂ§ç: response.data.data -> response.data")
            
        # ‰øÆÂ§ç‰∏çÂÆâÂÖ®ÁöÑÊï∞ÊçÆËÆøÈóÆ
        pattern4 = r'response\.(\w+)\['
        matches = re.findall(pattern4, content)
        for match in matches:
            old_pattern = f'response.{match}['
            new_pattern = f'response.{match}?.[' if match != 'status' else old_pattern
            if old_pattern in content and new_pattern != old_pattern:
                content = content.replace(old_pattern, new_pattern)
                fixes.append(f"‰øÆÂ§ç: Ê∑ªÂä†ÂÆâÂÖ®ËÆøÈóÆÁ¨¶ response.{match}?.[")
        
        if content != original_content:
            self.backup_file(file_path)
            file_path.write_text(content, encoding='utf-8')
            self.fixes_applied.extend([f"{file_path.name}: {fix}" for fix in fixes])
            return True
        return False
        
    def fix_error_handling(self, file_path):
        """Ê∑ªÂä†ÈîôËØØÂ§ÑÁêÜ"""
        content = file_path.read_text(encoding='utf-8')
        original_content = content
        fixes = []
        
        # Êü•ÊâæÊ≤°ÊúâÈîôËØØÂ§ÑÁêÜÁöÑ async ÂáΩÊï∞
        async_pattern = r'const\s+(\w+)\s*=\s*async\s*\([^)]*\)\s*=>\s*\{'
        matches = re.finditer(async_pattern, content)
        
        for match in matches:
            func_name = match.group(1)
            start_pos = match.end()
            
            # Êü•ÊâæÂáΩÊï∞ÁªìÊùü‰ΩçÁΩÆ
            brace_count = 1
            pos = start_pos
            while pos < len(content) and brace_count > 0:
                if content[pos] == '{':
                    brace_count += 1
                elif content[pos] == '}':
                    brace_count -= 1
                pos += 1
            
            if pos < len(content):
                func_body = content[start_pos-1:pos]
                
                # Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ await ‰ΩÜÊ≤°Êúâ try-catch
                if 'await' in func_body and 'try {' not in func_body and 'try{' not in func_body:
                    # Ê∑ªÂä† try-catch ÂåÖË£Ö
                    indented_body = '    ' + func_body[1:-1].replace('\n', '\n    ')
                    new_body = f'''{{
    try {{
{indented_body}
    }} catch (error) {{
      console.error('{func_name}Â§±Ë¥•:', error);
      message.error('{func_name}Â§±Ë¥•: ' + (error.response?.data?.message || error.message));
    }}
  }}'''
                    content = content[:start_pos-1] + new_body + content[pos:]
                    fixes.append(f"‰∏∫ÂáΩÊï∞ {func_name} Ê∑ªÂä†ÈîôËØØÂ§ÑÁêÜ")
        
        if content != original_content:
            self.backup_file(file_path)
            file_path.write_text(content, encoding='utf-8')
            self.fixes_applied.extend([f"{file_path.name}: {fix}" for fix in fixes])
            return True
        return False
        
    def fix_import_issues(self, file_path):
        """‰øÆÂ§çÂØºÂÖ•ÈóÆÈ¢ò"""
        content = file_path.read_text(encoding='utf-8')
        original_content = content
        fixes = []
        
        # Ê£ÄÊü•ÊòØÂê¶Áº∫Â∞ëÂøÖË¶ÅÁöÑÂØºÂÖ•
        if 'message.' in content and 'import { message' not in content:
            # Êü•ÊâæÁé∞ÊúâÁöÑ ant-design-vue ÂØºÂÖ•
            antd_import_pattern = r"import\s*\{([^}]+)\}\s*from\s*['\"]ant-design-vue['\"]"
            match = re.search(antd_import_pattern, content)
            
            if match:
                imports = match.group(1).strip()
                if 'message' not in imports:
                    new_imports = imports + ', message'
                    content = re.sub(antd_import_pattern, f"import {{ {new_imports} }} from 'ant-design-vue'", content)
                    fixes.append("Ê∑ªÂä† message ÂØºÂÖ•")
            else:
                # Ê∑ªÂä†Êñ∞ÁöÑÂØºÂÖ•
                script_match = re.search(r'<script[^>]*>', content)
                if script_match:
                    insert_pos = script_match.end()
                    import_line = "\nimport { message } from 'ant-design-vue';"
                    content = content[:insert_pos] + import_line + content[insert_pos:]
                    fixes.append("Ê∑ªÂä† ant-design-vue message ÂØºÂÖ•")
        
        if content != original_content:
            self.backup_file(file_path)
            file_path.write_text(content, encoding='utf-8')
            self.fixes_applied.extend([f"{file_path.name}: {fix}" for fix in fixes])
            return True
        return False
        
    def fix_vue_composition_api_issues(self, file_path):
        """‰øÆÂ§çVue Composition APIÈóÆÈ¢ò"""
        content = file_path.read_text(encoding='utf-8')
        original_content = content
        fixes = []
        
        # Ê£ÄÊü•ÊòØÂê¶‰ΩøÁî®‰∫ÜËøáÊó∂ÁöÑ @vue/composition-api
        if '@vue/composition-api' in content:
            content = content.replace("from '@vue/composition-api'", "from 'vue'")
            fixes.append("ÁßªÈô§ËøáÊó∂ÁöÑ @vue/composition-api ÂØºÂÖ•")
        
        # Ê£ÄÊü• reactive Âíå ref ÁöÑÊ≠£Á°Æ‰ΩøÁî®
        if 'reactive(' in content or 'ref(' in content:
            vue_import_pattern = r"import\s*\{([^}]+)\}\s*from\s*['\"]vue['\"]"
            match = re.search(vue_import_pattern, content)
            
            if match:
                imports = match.group(1).strip()
                needed_imports = []
                
                if 'reactive(' in content and 'reactive' not in imports:
                    needed_imports.append('reactive')
                if 'ref(' in content and 'ref' not in imports:
                    needed_imports.append('ref')
                if 'computed(' in content and 'computed' not in imports:
                    needed_imports.append('computed')
                if 'onMounted(' in content and 'onMounted' not in imports:
                    needed_imports.append('onMounted')
                if 'onUnmounted(' in content and 'onUnmounted' not in imports:
                    needed_imports.append('onUnmounted')
                if 'nextTick(' in content and 'nextTick' not in imports:
                    needed_imports.append('nextTick')
                    
                if needed_imports:
                    new_imports = imports + ', ' + ', '.join(needed_imports)
                    content = re.sub(vue_import_pattern, f"import {{ {new_imports} }} from 'vue'", content)
                    fixes.append(f"Ê∑ªÂä†VueÂØºÂÖ•: {', '.join(needed_imports)}")
        
        if content != original_content:
            self.backup_file(file_path)
            file_path.write_text(content, encoding='utf-8')
            self.fixes_applied.extend([f"{file_path.name}: {fix}" for fix in fixes])
            return True
        return False
        
    def fix_typescript_issues(self, file_path):
        """‰øÆÂ§çTypeScriptÁ±ªÂûãÈóÆÈ¢ò"""
        content = file_path.read_text(encoding='utf-8')
        original_content = content
        fixes = []
        
        # Ê∑ªÂä†Âü∫Êú¨ÁöÑÁ±ªÂûãÂÆâÂÖ®Ê£ÄÊü•
        patterns = [
            (r'(\w+)\.length(?!\s*>)', r'\1?.length'),  # ÂÆâÂÖ®ËÆøÈóÆÊï∞ÁªÑÈïøÂ∫¶
            (r'(\w+)\.map\(', r'\1?.map('),              # ÂÆâÂÖ®ËÆøÈóÆÊï∞ÁªÑÊñπÊ≥ï
            (r'(\w+)\.filter\(', r'\1?.filter('),        # ÂÆâÂÖ®ËÆøÈóÆÊï∞ÁªÑÊñπÊ≥ï
            (r'(\w+)\.find\(', r'\1?.find('),            # ÂÆâÂÖ®ËÆøÈóÆÊï∞ÁªÑÊñπÊ≥ï
        ]
        
        for pattern, replacement in patterns:
            if re.search(pattern, content):
                content = re.sub(pattern, replacement, content)
                fixes.append(f"Ê∑ªÂä†Á±ªÂûãÂÆâÂÖ®: {pattern} -> {replacement}")
        
        if content != original_content:
            self.backup_file(file_path)
            file_path.write_text(content, encoding='utf-8')
            self.fixes_applied.extend([f"{file_path.name}: {fix}" for fix in fixes])
            return True
        return False
        
    def fix_performance_issues(self, file_path):
        """‰øÆÂ§çÊÄßËÉΩÈóÆÈ¢ò"""
        content = file_path.read_text(encoding='utf-8')
        original_content = content
        fixes = []
        
        # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊ∑ªÂä†Èò≤Êäñ
        if 'onSearch' in content and 'debounce' not in content:
            # ÁÆÄÂçïÁöÑÈò≤ÊäñÂª∫ËÆÆÔºà‰∏çËá™Âä®‰øÆÂ§çÔºåÂè™ËÆ∞ÂΩïÔºâ
            fixes.append("Âª∫ËÆÆ: ‰∏∫ÊêúÁ¥¢ÂäüËÉΩÊ∑ªÂä†Èò≤Êäñ")
        
        # Ê£ÄÊü•ÊòØÂê¶ÊúâÂ§ßÈáèÁöÑDOMÊìç‰ΩúÂèØ‰ª•‰ºòÂåñ
        if content.count('document.querySelector') > 3:
            fixes.append("Âª∫ËÆÆ: ‰ΩøÁî®Vue refÊõø‰ª£Áõ¥Êé•DOMÊü•ËØ¢")
        
        if fixes:
            self.fixes_applied.extend([f"{file_path.name}: {fix}" for fix in fixes])
            return True
        return False
        
    def run_fixes(self):
        """ËøêË°åÊâÄÊúâ‰øÆÂ§ç"""
        print("üöÄ ÂºÄÂßãËá™Âä®‰øÆÂ§çÂâçÁ´Ø‰ª£Á†Å...")
        print("=" * 50)
        
        vue_files = list(self.frontend_path.glob("**/*.vue"))
        js_files = list(self.frontend_path.glob("**/*.js"))
        
        total_files = len(vue_files) + len(js_files)
        fixed_files = 0
        
        for file_path in vue_files + js_files:
            print(f"\nüìù Ê£ÄÊü•Êñá‰ª∂: {file_path.relative_to(self.frontend_path)}")
            
            try:
                file_fixed = False
                
                # Â∫îÁî®ÂêÑÁßç‰øÆÂ§ç
                if self.fix_api_data_access(file_path):
                    file_fixed = True
                    
                if self.fix_import_issues(file_path):
                    file_fixed = True
                    
                if self.fix_vue_composition_api_issues(file_path):
                    file_fixed = True
                    
                # if self.fix_error_handling(file_path):
                #     file_fixed = True
                    
                if self.fix_typescript_issues(file_path):
                    file_fixed = True
                    
                if self.fix_performance_issues(file_path):
                    file_fixed = True
                    
                if file_fixed:
                    fixed_files += 1
                    print(f"‚úÖ Â∑≤‰øÆÂ§ç")
                else:
                    print(f"‚úÖ Êó†ÈúÄ‰øÆÂ§ç")
                    
            except Exception as e:
                print(f"‚ùå ‰øÆÂ§çÂ§±Ë¥•: {str(e)}")
        
        # ÁîüÊàê‰øÆÂ§çÊä•Âëä
        self.generate_report(total_files, fixed_files)
        
    def generate_report(self, total_files, fixed_files):
        """ÁîüÊàê‰øÆÂ§çÊä•Âëä"""
        print("\n" + "=" * 50)
        print("üìã Ëá™Âä®‰øÆÂ§çÊä•Âëä")
        print("=" * 50)
        
        print(f"üìä Êñá‰ª∂ÁªüËÆ°:")
        print(f"   ÊÄªÊñá‰ª∂Êï∞: {total_files}")
        print(f"   ‰øÆÂ§çÊñá‰ª∂Êï∞: {fixed_files}")
        if total_files > 0:
            print(f"   ‰øÆÂ§çÁéá: {fixed_files/total_files*100:.1f}%")
        else:
            print("   ‰øÆÂ§çÁéá: 0%ÔºàÊú™ÊâæÂà∞Êñá‰ª∂Ôºâ")
        
        print(f"\nüîß ‰øÆÂ§çËØ¶ÊÉÖ:")
        if not self.fixes_applied:
            print("   Êó†ÈúÄË¶Å‰øÆÂ§çÁöÑÈóÆÈ¢ò")
        else:
            for i, fix in enumerate(self.fixes_applied, 1):
                print(f"   {i}. {fix}")
        
        # ‰øùÂ≠òËØ¶ÁªÜÊä•Âëä
        report = {
            "fix_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "total_files": total_files,
            "fixed_files": fixed_files,
            "fixes_applied": self.fixes_applied,
            "backup_directory": str(self.backup_dir)
        }
        
        with open("frontend_auto_fix_report.json", "w", encoding="utf-8") as f:
            json.dump(report, f, ensure_ascii=False, indent=2)
        
        print(f"\nüìÑ ËØ¶ÁªÜÊä•ÂëäÂ∑≤‰øùÂ≠òÂà∞: frontend_auto_fix_report.json")
        if self.backup_dir.exists():
            print(f"üìÅ Â§á‰ªΩÊñá‰ª∂‰øùÂ≠òÂú®: {self.backup_dir}")

def main():
    fixer = FrontendAutoFixer()
    fixer.run_fixes()

if __name__ == "__main__":
    main() 