# 场景分析服务设计

## 🎯 功能目标

从小说文本中智能提取场景信息，为环境音生成提供精确的上下文标签。

## 🧠 AI分析策略

### 场景维度分析
```python
class SceneAnalyzer:
    def analyze_scene(self, text: str) -> SceneInfo:
        return {
            "location": self._detect_location(text),      # 地点
            "weather": self._detect_weather(text),        # 天气
            "time": self._detect_time(text),              # 时间
            "atmosphere": self._detect_atmosphere(text),   # 氛围
            "action": self._detect_action(text),          # 动作
            "emotion": self._detect_emotion(text)         # 情绪
        }
```

### 1. 地点检测 (Location Detection)
**规则库 + AI模型**
```python
LOCATION_KEYWORDS = {
    "indoor": ["房间", "屋子", "客厅", "卧室", "厨房", "办公室", "教室"],
    "outdoor": ["街道", "公园", "花园", "山上", "海边", "森林"],
    "transport": ["车里", "飞机上", "火车上", "船上"],
    "public": ["餐厅", "咖啡厅", "商场", "医院", "学校", "图书馆"],
    "special": ["地下室", "阁楼", "废墟", "洞穴", "宫殿"]
}

def _detect_location(self, text: str) -> str:
    # 1. 关键词匹配
    for location_type, keywords in LOCATION_KEYWORDS.items():
        for keyword in keywords:
            if keyword in text:
                return location_type
                
    # 2. AI语义理解
    prompt = f"分析这段文字的地点类型: {text}"
    ai_result = self.ollama_client.analyze(prompt)
    return ai_result.location
```

### 2. 天气检测 (Weather Detection)
```python
WEATHER_PATTERNS = {
    "rainy": ["下雨", "雨天", "雨水", "雨声", "湿润", "雨滴"],
    "sunny": ["阳光", "晴天", "明媚", "温暖", "晴朗"],
    "windy": ["大风", "风声", "刮风", "呼呼", "微风"],
    "snowy": ["下雪", "雪花", "雪地", "寒冷", "雪白"],
    "cloudy": ["阴天", "多云", "灰蒙蒙", "阴沉"],
    "stormy": ["暴雨", "雷声", "闪电", "暴风雨"]
}
```

### 3. 时间检测 (Time Detection)
```python
TIME_PATTERNS = {
    "morning": ["早晨", "上午", "黎明", "清晨", "日出"],
    "afternoon": ["下午", "午后", "正午", "中午"],
    "evening": ["傍晚", "黄昏", "夕阳", "日落"],
    "night": ["夜晚", "深夜", "半夜", "夜深", "月亮"],
    "dawn": ["破晓", "拂晓", "天亮", "东方"]
}
```

### 4. 氛围检测 (Atmosphere Detection)
```python
ATMOSPHERE_PATTERNS = {
    "tense": ["紧张", "恐惧", "惊恐", "害怕", "焦虑"],
    "calm": ["平静", "安静", "宁静", "祥和", "放松"],
    "romantic": ["浪漫", "温馨", "甜蜜", "爱意", "柔情"],
    "mysterious": ["神秘", "诡异", "奇怪", "不明", "阴森"],
    "exciting": ["激动", "兴奋", "刺激", "热血", "澎湃"],
    "sad": ["悲伤", "难过", "哭泣", "忧郁", "伤心"]
}
```

## 🔄 场景持续性分析

### 场景切换检测
```python
def detect_scene_change(self, current_scene: SceneInfo, previous_scene: SceneInfo) -> bool:
    """检测场景是否发生变化"""
    
    # 主要变化指标
    major_changes = [
        current_scene.location != previous_scene.location,
        current_scene.weather != previous_scene.weather,
        current_scene.time != previous_scene.time
    ]
    
    # 氛围变化 (次要)
    atmosphere_change = current_scene.atmosphere != previous_scene.atmosphere
    
    return any(major_changes) or atmosphere_change
```

### 场景持续时长预估
```python
def estimate_scene_duration(self, scene_segments: List[dict]) -> float:
    """预估场景持续时长"""
    
    total_chars = sum(len(seg["content"]) for seg in scene_segments)
    dialogue_count = sum(1 for seg in scene_segments if seg["type"] == "dialogue")
    
    # 基础时长 = 字数 * 0.3秒 + 对话停顿
    base_duration = total_chars * 0.3 + dialogue_count * 0.5
    
    return max(base_duration, 2.0)  # 最少2秒
```

## 🎵 环境音映射策略

### 智能音效选择
```python
class EnvironmentSoundMapper:
    def map_scene_to_sound(self, scene: SceneInfo) -> str:
        """将场景映射到具体的环境音文件"""
        
        # 构建音效标识符
        sound_id_parts = []
        
        # 基础环境
        if scene.location == "outdoor" and scene.weather == "rainy":
            sound_id_parts.append("rain")
        elif scene.location == "indoor":
            sound_id_parts.append("indoor")
        elif scene.location == "forest":
            sound_id_parts.append("forest")
            
        # 天气修饰
        if scene.weather == "windy":
            sound_id_parts.append("windy")
        elif scene.weather == "stormy":
            sound_id_parts.append("storm")
            
        # 时间修饰
        if scene.time == "night":
            sound_id_parts.append("night")
        elif scene.time == "morning":
            sound_id_parts.append("morning")
            
        # 氛围修饰
        if scene.atmosphere == "tense":
            sound_id_parts.append("tense")
        elif scene.atmosphere == "calm":
            sound_id_parts.append("calm")
            
        return "_".join(sound_id_parts) + ".wav"
```

### 音效组合策略
```python
SOUND_COMBINATIONS = {
    "rainy_night_outdoor": {
        "primary": "rain_heavy.wav",
        "secondary": "night_ambience.wav", 
        "mix_ratio": 0.7  # primary音量比例
    },
    "forest_morning_calm": {
        "primary": "forest_birds.wav",
        "secondary": "wind_gentle.wav",
        "mix_ratio": 0.8
    },
    "indoor_night_tense": {
        "primary": "silence_tense.wav",
        "secondary": "clock_ticking.wav",
        "mix_ratio": 0.6
    }
}
```

## 📊 输出数据结构

### SceneInfo数据类
```python
@dataclass
class SceneInfo:
    location: str           # "indoor", "outdoor", "forest", etc.
    weather: str           # "rainy", "sunny", "windy", etc.
    time: str             # "morning", "afternoon", "evening", "night"
    atmosphere: str       # "calm", "tense", "romantic", etc.
    action: str          # "walking", "sitting", "running", etc.
    emotion: str         # "happy", "sad", "angry", etc.
    confidence: float    # 分析置信度 0-1
    duration_estimate: float  # 预估持续时间(秒)
    environment_sounds: List[str]  # 推荐的环境音文件列表
    scene_id: str        # 唯一场景标识符
    transition_type: str # "instant", "fade", "cross_fade"
```

### API接口设计
```python
@router.post("/api/v1/scene-analysis/analyze")
async def analyze_scene(request: SceneAnalysisRequest):
    """分析文本场景信息"""
    
    analyzer = SceneAnalyzer()
    scene_info = analyzer.analyze_scene(request.text)
    
    return {
        "success": True,
        "data": {
            "scene_info": scene_info,
            "suggested_sounds": scene_info.environment_sounds,
            "confidence": scene_info.confidence
        }
    }

@router.post("/api/v1/scene-analysis/batch")  
async def batch_analyze_scenes(request: BatchSceneAnalysisRequest):
    """批量分析多个文本段的场景"""
    
    analyzer = SceneAnalyzer()
    results = []
    
    for i, text_segment in enumerate(request.segments):
        scene_info = analyzer.analyze_scene(text_segment.content)
        
        # 检测场景切换
        if i > 0:
            previous_scene = results[i-1]["scene_info"]
            scene_change = analyzer.detect_scene_change(scene_info, previous_scene)
            scene_info.is_scene_change = scene_change
            
        results.append({
            "segment_index": i,
            "scene_info": scene_info,
            "suggested_sounds": scene_info.environment_sounds
        })
    
    return {
        "success": True,
        "data": {
            "scenes": results,
            "total_scenes": len(results),
            "scene_changes": len([r for r in results if r["scene_info"].is_scene_change])
        }
    }
```

## 🧪 测试用例

### 场景识别测试
```python
TEST_CASES = [
    {
        "text": "夜深了，外面下着小雨，张三独自坐在房间里。",
        "expected": {
            "location": "indoor",
            "weather": "rainy", 
            "time": "night",
            "atmosphere": "calm"
        }
    },
    {
        "text": "突然一声巨响，雷电划破了黑暗的夜空！",
        "expected": {
            "location": "outdoor",
            "weather": "stormy",
            "time": "night", 
            "atmosphere": "tense"
        }
    }
]
```

---

**下一步**：实现时间轴生成器，将场景信息转换为音频混合时间轴