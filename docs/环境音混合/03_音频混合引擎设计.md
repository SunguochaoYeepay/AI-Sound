# åŸºäºæ–‡ä»¶çš„éŸ³é¢‘æ··åˆå¼•æ“

## ğŸ¯ æ ¸å¿ƒä»·å€¼

åŸºäºé¡ºåºç”Ÿæˆçš„éŸ³é¢‘æ–‡ä»¶ï¼Œä½¿ç”¨CPUè¿›è¡Œæ™ºèƒ½æ··åˆï¼Œé¿å…GPUèµ„æºå†²çªï¼Œç¡®ä¿æ··åˆè´¨é‡ã€‚

## ğŸ”„ åŸºäºæ–‡ä»¶çš„æ··åˆç­–ç•¥

### æ–‡ä»¶æ··åˆæ¶æ„
```python
class FileBasedAudioMixer:
    def __init__(self):
        self.audio_loader = AudioFileLoader()
        self.ducking_processor = DuckingProcessor()
        self.quality_enhancer = AudioQualityEnhancer()
    
    def mix_audio_files(
        self,
        dialogue_files: List[str],
        environment_files: List[str], 
        timeline: Timeline
    ) -> MixedAudio:
        # 1. åŠ è½½æ‰€æœ‰éŸ³é¢‘æ–‡ä»¶
        dialogue_tracks = self._load_dialogue_files(dialogue_files)
        environment_tracks = self._load_environment_files(environment_files)
        
        # 2. åˆ›å»ºä¸»éŸ³è½¨
        master_track = self._create_master_track(timeline.total_duration)
        
        # 3. åˆ†å±‚æ··åˆ
        master_track = self._mix_environment_layer(master_track, environment_tracks, timeline)
        master_track = self._mix_dialogue_layer(master_track, dialogue_tracks, timeline)
        
        # 4. æ™ºèƒ½é—ªé¿å’Œè´¨é‡ä¼˜åŒ–
        final_audio = self._apply_ducking_and_enhancement(master_track)
        
        return final_audio
```

## ğŸµ æ™ºèƒ½é—ªé¿ç®—æ³•

### å¯¹è¯æ—¶ç¯å¢ƒéŸ³è‡ªåŠ¨é™ä½
```python
def _apply_intelligent_ducking(self, master_track: AudioTrack, timeline: Timeline) -> AudioTrack:
    """æ™ºèƒ½é—ªé¿ï¼šå¯¹è¯æ—¶ç¯å¢ƒéŸ³è‡ªåŠ¨é™ä½"""
    
    ducked_track = master_track.copy()
    
    for dialogue_segment in timeline.dialogue_segments:
        start_time = dialogue_segment.start
        end_time = dialogue_segment.end
        
        # é—ªé¿å‚æ•°
        duck_amount = -6.0  # é™ä½6dB
        duck_attack = 0.1   # 100msæ¸å…¥
        duck_release = 0.3  # 300msæ¸å‡º
        
        # åº”ç”¨é—ªé¿æ•ˆæœ
        ducked_track = ducked_track.apply_ducking(
            start_time=start_time - duck_attack,
            end_time=end_time + duck_release,
            reduction_db=duck_amount,
            attack_time=duck_attack,
            release_time=duck_release
        )
    
    return ducked_track
```

### åŸºäºpydubçš„å®ç°
```python
from pydub import AudioSegment

def _mix_with_pydub(self, dialogue_files: List[str], environment_files: List[str], timeline: Timeline) -> AudioSegment:
    """ä½¿ç”¨pydubè¿›è¡ŒéŸ³é¢‘æ··åˆ"""
    
    # 1. åˆ›å»ºé™éŸ³ä¸»è½¨
    total_duration_ms = int(timeline.total_duration * 1000)
    master_track = AudioSegment.silent(duration=total_duration_ms)
    
    # 2. æ·»åŠ ç¯å¢ƒéŸ³
    for env_track in timeline.environment_tracks:
        env_audio = AudioSegment.from_wav(env_track.file_path)
        start_ms = int(env_track.start * 1000)
        
        # è°ƒèŠ‚éŸ³é‡
        volume_adjusted = env_audio + env_track.volume_db
        
        # å åŠ åˆ°ä¸»è½¨
        master_track = master_track.overlay(volume_adjusted, position=start_ms)
    
    # 3. æ·»åŠ å¯¹è¯éŸ³é¢‘
    for dialogue_segment in timeline.dialogue_segments:
        dialogue_audio = AudioSegment.from_wav(dialogue_segment.file_path)
        start_ms = int(dialogue_segment.start * 1000)
        
        # å¯¹è¯éŸ³é¢‘ä¼˜å…ˆçº§æ›´é«˜
        master_track = master_track.overlay(dialogue_audio, position=start_ms)
    
    return master_track
```

## ğŸ“¤ å¤šæ ¼å¼å¯¼å‡º

### æ”¯æŒæ ¼å¼
```python
EXPORT_FORMATS = {
    "high_quality": {
        "format": "wav",
        "sample_rate": 48000,
        "bit_depth": 24,
        "channels": 2
    },
    "streaming": {
        "format": "mp3", 
        "bitrate": 320,
        "channels": 2
    },
    "mobile": {
        "format": "aac",
        "bitrate": 128,
        "channels": 2
    }
}

def export_mixed_audio(self, mixed_audio: AudioSegment, format_type: str = "high_quality") -> str:
    """å¯¼å‡ºæ··åˆéŸ³é¢‘"""
    
    config = EXPORT_FORMATS[format_type]
    output_path = f"mixed_audio_{int(time.time())}.{config['format']}"
    
    # åº”ç”¨å¯¼å‡ºè®¾ç½®
    if config["format"] == "wav":
        mixed_audio.export(output_path, format="wav")
    elif config["format"] == "mp3":
        mixed_audio.export(output_path, format="mp3", bitrate=f"{config['bitrate']}k")
    elif config["format"] == "aac":
        mixed_audio.export(output_path, format="mp4", codec="aac", bitrate=f"{config['bitrate']}k")
    
    return output_path
```

---

**æ ¸å¿ƒä»·å€¼**: åŸºäºpydubçš„ç®€æ´æ··åˆæ–¹æ¡ˆï¼ŒCPUå¤„ç†é¿å…GPUå†²çªï¼Œç¡®ä¿ç¨³å®šæ€§ï¼