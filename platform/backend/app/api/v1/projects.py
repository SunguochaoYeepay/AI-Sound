"""
È°πÁõÆÁÆ°ÁêÜAPI
Êèê‰æõTTSÈ°πÁõÆÁÆ°ÁêÜÂäüËÉΩ
"""

from fastapi import APIRouter, Depends, HTTPException, Query, Form, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy import desc, asc, func, or_, and_
from typing import List, Optional, Dict, Any
import json
import logging
from datetime import datetime

from app.database import get_db
from app.models import NovelProject, VoiceProfile, Book  # üöÄ TextSegmentÂ∑≤Âà†Èô§
from app.utils import log_system_event

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/projects", tags=["Projects"])

@router.get("")
async def get_projects(
    page: int = Query(1, ge=1, description="È°µÁ†Å"),
    page_size: int = Query(20, ge=1, le=100, description="ÊØèÈ°µÊï∞Èáè"),
    search: str = Query("", description="ÊêúÁ¥¢ÂÖ≥ÈîÆËØç"),
    status: str = Query("", description="Áä∂ÊÄÅËøáÊª§"),
    book_id: Optional[int] = Query(None, description="‰π¶Á±çIDËøáÊª§"),
    sort_by: str = Query("created_at", description="ÊéíÂ∫èÂ≠óÊÆµ"),
    sort_order: str = Query("desc", description="ÊéíÂ∫èÊñπÂêë"),
    db: Session = Depends(get_db)
):
    """Ëé∑ÂèñÈ°πÁõÆÂàóË°®"""
    try:
        # ÊûÑÂª∫Êü•ËØ¢
        query = db.query(NovelProject)
        
        # ÊêúÁ¥¢ËøáÊª§
        if search:
            search_pattern = f"%{search}%"
            query = query.filter(
                or_(
                    NovelProject.name.like(search_pattern),
                    NovelProject.description.like(search_pattern)
                )
            )
        
        # Áä∂ÊÄÅËøáÊª§
        if status and status in ['pending', 'processing', 'paused', 'completed', 'failed']:
            query = query.filter(NovelProject.status == status)
        
        # ‰π¶Á±çIDËøáÊª§
        if book_id:
            query = query.filter(NovelProject.book_id == book_id)
        
        # ÊéíÂ∫è
        sort_field = getattr(NovelProject, sort_by, NovelProject.created_at)
        if sort_order == "asc":
            query = query.order_by(asc(sort_field))
        else:
            query = query.order_by(desc(sort_field))
        
        # ÁªüËÆ°ÊÄªÊï∞
        total = query.count()
        
        # ÂàÜÈ°µ
        offset = (page - 1) * page_size
        projects = query.offset(offset).limit(page_size).all()
        
        # ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè
        project_list = []
        for project in projects:
            # üöÄ Êñ∞Êû∂ÊûÑÔºöÂä®ÊÄÅËÆ°ÁÆóËøõÂ∫¶
            progress = 0
            
            # Ëé∑ÂèñÂÆûÈôÖÂÆåÊàêÁöÑÈü≥È¢ëÊñá‰ª∂Êï∞Èáè
            audio_count = db.query(AudioFile).filter(
                AudioFile.project_id == project.id,
                AudioFile.audio_type == 'segment'
            ).count()
            
            # Ëé∑ÂèñÊô∫ËÉΩÂáÜÂ§áÁöÑÊÄªÊÆµËêΩÊï∞Èáè
            total_count = 0
            if project.book_id:
                from app.models import AnalysisResult, BookChapter
                analysis_results = db.query(AnalysisResult).join(
                    BookChapter, AnalysisResult.chapter_id == BookChapter.id
                ).filter(
                    BookChapter.book_id == project.book_id,
                    AnalysisResult.status == 'completed',
                    AnalysisResult.synthesis_plan.isnot(None)
                ).all()
                
                for result in analysis_results:
                    if result.synthesis_plan and 'synthesis_plan' in result.synthesis_plan:
                        segments = result.synthesis_plan['synthesis_plan']
                        total_count += len(segments)
            
            # ËÆ°ÁÆóËøõÂ∫¶ÁôæÂàÜÊØî
            if total_count > 0:
                progress = round((audio_count / total_count) * 100, 1)
            
            project_data = project.to_dict()
            project_data['progress'] = progress
            project_list.append(project_data)
        
        # ÂàÜÈ°µ‰ø°ÊÅØ
        total_pages = (total + page_size - 1) // page_size
        
        return {
            "success": True,
            "data": project_list,
            "pagination": {
                "page": page,
                "pageSize": page_size,
                "total": total,
                "totalPages": total_pages,
                "hasMore": page < total_pages
            },
            "filters": {
                "search": search,
                "status": status,
                "book_id": book_id
            }
        }
        
    except Exception as e:
        logger.error(f"Ëé∑ÂèñÈ°πÁõÆÂàóË°®Â§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÈ°πÁõÆÂàóË°®Â§±Ë¥•: {str(e)}")

@router.post("")
async def create_project(
    name: str = Form(...),
    description: str = Form(""),
    content: str = Form(""),
    book_id: Optional[int] = Form(None),
    initial_characters: str = Form("[]"),
    settings: str = Form("{}"),
    db: Session = Depends(get_db)
):
    """ÂàõÂª∫È°πÁõÆ"""
    try:
        # È™åËØÅÈ°πÁõÆÂêçÁß∞
        if not name or len(name.strip()) == 0:
            raise HTTPException(status_code=400, detail="È°πÁõÆÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫")
        
        # Ê£ÄÊü•È°πÁõÆÂêçÁß∞ÊòØÂê¶Â∑≤Â≠òÂú®
        existing = db.query(NovelProject).filter(NovelProject.name == name).first()
        if existing:
            raise HTTPException(status_code=400, detail="È°πÁõÆÂêçÁß∞Â∑≤Â≠òÂú®")
        
        # Ëé∑ÂèñÊñáÊú¨ÂÜÖÂÆπ
        text_content = ""
        actual_book_id = None
        
        if book_id:
            # Âü∫‰∫é‰π¶Á±çÂàõÂª∫
            book = db.query(Book).filter(Book.id == book_id).first()
            if not book:
                raise HTTPException(status_code=404, detail="ÊåáÂÆöÁöÑ‰π¶Á±ç‰∏çÂ≠òÂú®")
            
            if not book.content or len(book.content.strip()) == 0:
                raise HTTPException(status_code=400, detail="‰π¶Á±çÂÜÖÂÆπ‰∏∫Á©∫ÔºåÊó†Ê≥ïÂàõÂª∫È°πÁõÆ")
            
            text_content = book.content
            actual_book_id = book_id
        elif content and content.strip():
            # Áõ¥Êé•ËæìÂÖ•ÊñáÊú¨
            text_content = content.strip()
            actual_book_id = None
        else:
            raise HTTPException(status_code=400, detail="ÂøÖÈ°ªÊèê‰æõ‰π¶Á±çIDÊàñÊñáÊú¨ÂÜÖÂÆπ")
        
        # Ëß£ÊûêÂàùÂßãËßíËâ≤Êò†Â∞Ñ
        try:
            initial_chars = json.loads(initial_characters) if initial_characters else []
        except json.JSONDecodeError:
            raise HTTPException(status_code=400, detail="ÂàùÂßãËßíËâ≤Ê†ºÂºèÈîôËØØ")
        
        # Ëß£ÊûêÈ°πÁõÆËÆæÁΩÆ
        try:
            project_settings = json.loads(settings) if settings else {}
        except json.JSONDecodeError:
            raise HTTPException(status_code=400, detail="È°πÁõÆËÆæÁΩÆÊ†ºÂºèÈîôËØØ")
        
        # ÂàõÂª∫È°πÁõÆËÆ∞ÂΩï
        project = NovelProject(
            name=name,
            description=description,
            book_id=actual_book_id,
            status='pending',
            created_at=datetime.utcnow()
        )
        
        # ËÆæÁΩÆÂàùÂßãËßíËâ≤Êò†Â∞Ñ
        char_mapping = {}
        if initial_chars:
            for char_info in initial_chars:
                if isinstance(char_info, dict) and 'name' in char_info and 'voice_id' in char_info:
                    char_mapping[char_info['name']] = char_info['voice_id']
        
        if hasattr(project, 'set_character_mapping'):
            project.set_character_mapping(char_mapping)
        elif hasattr(project, 'character_mapping'):
            project.character_mapping = json.dumps(char_mapping)
        
        # ËÆæÁΩÆÈ°πÁõÆÈÖçÁΩÆ
        if project_settings and hasattr(project, 'set_settings'):
            project.set_settings(project_settings)
        
        db.add(project)
        db.flush()  # Ëé∑ÂèñÈ°πÁõÆID
        
        # üöÄ Êñ∞Êû∂ÊûÑÔºö‰∏çÂÜçÈúÄË¶Å‰º†ÁªüÂàÜÊÆµÔºå‰ΩøÁî®Êô∫ËÉΩÂáÜÂ§áÊ®°Âºè
        segments_count = 0
        # Êñ∞Êû∂ÊûÑÔºöÈ°πÁõÆÂàõÂª∫Êó∂‰∏çÂàÜÊÆµÔºåÁ≠âÂæÖÊô∫ËÉΩÂáÜÂ§áÁªìÊûúËøõË°åÂêàÊàê
        
        db.commit()
        
        # ËÆ∞ÂΩïÂàõÂª∫Êó•Âøó
        await log_system_event(
            db=db,
            level="info",
            message=f"È°πÁõÆÂàõÂª∫: {name}",
            module="projects",
            details={
                "project_id": project.id,
                "book_id": book_id,
                "segments_count": segments_count
            }
        )
        
        return {
            "success": True,
            "message": "È°πÁõÆÂàõÂª∫ÊàêÂäü",
            "data": project.to_dict()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ÂàõÂª∫È°πÁõÆÂ§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ÂàõÂª∫Â§±Ë¥•: {str(e)}")

@router.get("/{project_id}")
async def get_project(
    project_id: int,
    db: Session = Depends(get_db)
):
    """Ëé∑ÂèñÈ°πÁõÆËØ¶ÊÉÖ"""
    try:
        project = db.query(NovelProject).filter(NovelProject.id == project_id).first()
        if not project:
            raise HTTPException(status_code=404, detail="È°πÁõÆ‰∏çÂ≠òÂú®")
        
        # üöÄ Êñ∞Êû∂ÊûÑÔºöÂü∫‰∫éAudioFileËé∑Âèñ‰ø°ÊÅØ
        from app.models import AudioFile
        audio_files = db.query(AudioFile).filter(
            AudioFile.project_id == project_id,
            AudioFile.audio_type == 'segment'
        ).all()
        
        # üö® È°πÁõÆÁ∫ßÂà´ËøõÂ∫¶ËÆ°ÁÆóÂ∑≤Â∫üÂºÉ
        logger.warning(f"‚ö†Ô∏è È°πÁõÆËØ¶ÊÉÖAPI‰∏≠ÁöÑËøõÂ∫¶ËÆ°ÁÆóÂ∑≤Â∫üÂºÉÔºåÈ°πÁõÆID: {project_id}")
        progress = 0  # ‰∏çÂÜçËÆ°ÁÆóÈ°πÁõÆÁ∫ßÂà´ËøõÂ∫¶
        
        # Ëé∑ÂèñËßíËâ≤ÁªüËÆ°
        character_stats = {}
        for audio_file in audio_files:
            speaker = audio_file.speaker or audio_file.character_name
            if speaker:
                if speaker not in character_stats:
                    character_stats[speaker] = {"count": 0, "voice_assigned": False}
                character_stats[speaker]["count"] += 1
                if audio_file.voice_profile_id:
                    character_stats[speaker]["voice_assigned"] = True
        
        project_data = project.to_dict()
        project_data.update({
            "progress": progress,
            "character_stats": character_stats,
            "audio_files_preview": [
                {
                    "id": a.id,
                    "order": a.paragraph_index,
                    "text": a.text_content[:100] + "..." if a.text_content and len(a.text_content) > 100 else (a.text_content or ""),
                    "speaker": a.speaker or a.character_name,
                    "voice_profile_id": a.voice_profile_id,
                    "status": a.status,
                    "duration": a.duration
                }
                for a in audio_files[:10]  # Âè™ËøîÂõûÂâç10‰∏™Èü≥È¢ëÊñá‰ª∂È¢ÑËßà
            ]
        })
        
        return {
            "success": True,
            "data": project_data
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Ëé∑ÂèñÈ°πÁõÆËØ¶ÊÉÖÂ§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñÈ°πÁõÆËØ¶ÊÉÖÂ§±Ë¥•: {str(e)}")

@router.patch("/{project_id}")
async def update_project(
    project_id: int,
    name: Optional[str] = Form(None),
    description: Optional[str] = Form(None),
    character_mapping: Optional[str] = Form(None),
    db: Session = Depends(get_db)
):
    """Êõ¥Êñ∞È°πÁõÆ‰ø°ÊÅØ"""
    try:
        project = db.query(NovelProject).filter(NovelProject.id == project_id).first()
        if not project:
            raise HTTPException(status_code=404, detail="È°πÁõÆ‰∏çÂ≠òÂú®")
        
        # Êõ¥Êñ∞Â≠óÊÆµ
        if name is not None:
            if not name.strip():
                raise HTTPException(status_code=400, detail="È°πÁõÆÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫")
            
            # Ê£ÄÊü•ÂêçÁß∞ÂÜ≤Á™Å
            existing = db.query(NovelProject).filter(
                NovelProject.name == name,
                NovelProject.id != project_id
            ).first()
            if existing:
                raise HTTPException(status_code=400, detail="È°πÁõÆÂêçÁß∞Â∑≤Â≠òÂú®")
            
            project.name = name.strip()
        
        if description is not None:
            project.description = description.strip()
        
        if character_mapping is not None:
            try:
                char_mapping = json.loads(character_mapping)
                if hasattr(project, 'set_character_mapping'):
                    project.set_character_mapping(char_mapping)
                elif hasattr(project, 'character_mapping'):
                    project.character_mapping = character_mapping
            except json.JSONDecodeError:
                raise HTTPException(status_code=400, detail="ËßíËâ≤Êò†Â∞ÑÊ†ºÂºèÈîôËØØ")
        
        project.updated_at = datetime.utcnow()
        db.commit()
        
        # ËÆ∞ÂΩïÊõ¥Êñ∞Êó•Âøó
        await log_system_event(
            db=db,
            level="info",
            message=f"È°πÁõÆÊõ¥Êñ∞: {project.name}",
            module="projects",
            details={"project_id": project_id}
        )
        
        return {
            "success": True,
            "message": "È°πÁõÆÊõ¥Êñ∞ÊàêÂäü",
            "data": project.to_dict()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Êõ¥Êñ∞È°πÁõÆÂ§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Êõ¥Êñ∞Â§±Ë¥•: {str(e)}")

@router.delete("/{project_id}")
async def delete_project(
    project_id: int,
    force: bool = Query(False, description="Âº∫Âà∂Âà†Èô§"),
    db: Session = Depends(get_db)
):
    """Âà†Èô§È°πÁõÆ"""
    try:
        project = db.query(NovelProject).filter(NovelProject.id == project_id).first()
        if not project:
            raise HTTPException(status_code=404, detail="È°πÁõÆ‰∏çÂ≠òÂú®")
        
        # Ê£ÄÊü•ÊòØÂê¶Ê≠£Âú®Â§ÑÁêÜ
        if not force and project.status == 'processing':
            raise HTTPException(
                status_code=400, 
                detail="È°πÁõÆÊ≠£Âú®Â§ÑÁêÜ‰∏≠ÔºåËØ∑‰ΩøÁî®Âº∫Âà∂Âà†Èô§"
            )
        
        project_name = project.name
        
        # üöÄ Êñ∞Êû∂ÊûÑÔºöÂà†Èô§ÂÖ≥ËÅîÁöÑAudioFile
        from app.models import AudioFile
        db.query(AudioFile).filter(AudioFile.project_id == project_id).delete()
        
        # Âà†Èô§È°πÁõÆ
        db.delete(project)
        db.commit()
        
        # ËÆ∞ÂΩïÂà†Èô§Êó•Âøó
        await log_system_event(
            db=db,
            level="info",
            message=f"È°πÁõÆÂà†Èô§: {project_name}",
            module="projects",
            details={"project_id": project_id, "force": force}
        )
        
        return {
            "success": True,
            "message": "È°πÁõÆÂà†Èô§ÊàêÂäü"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Âà†Èô§È°πÁõÆÂ§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Âà†Èô§Â§±Ë¥•: {str(e)}")

# Ê≥®ÈáäÊéâprojects APIÁöÑËøõÂ∫¶Á´ØÁÇπÔºåÁªü‰∏Ä‰ΩøÁî®novel_reader API
# @router.get("/{project_id}/progress")
# async def get_project_progress(
#     project_id: int,
#     db: Session = Depends(get_db)
# ):
#     """Ëé∑ÂèñÈ°πÁõÆËøõÂ∫¶ - Â∑≤ÂºÉÁî®ÔºåËØ∑‰ΩøÁî® /api/v1/novel-reader/projects/{project_id}/progress"""
#     pass

@router.post("/{project_id}/start")
async def start_project_generation(
    project_id: int,
    parallel_tasks: int = Form(1, description="Âπ∂Ë°å‰ªªÂä°Êï∞"),
    db: Session = Depends(get_db)
):
    """ÂºÄÂßãÈ°πÁõÆÁîüÊàê"""
    try:
        project = db.query(NovelProject).filter(NovelProject.id == project_id).first()
        if not project:
            raise HTTPException(status_code=404, detail="È°πÁõÆ‰∏çÂ≠òÂú®")
        
        if project.status == 'processing':
            raise HTTPException(status_code=400, detail="È°πÁõÆÂ∑≤Âú®Â§ÑÁêÜ‰∏≠")
        
        if project.status == 'completed':
            raise HTTPException(status_code=400, detail="È°πÁõÆÂ∑≤ÂÆåÊàê")
        
        # Êõ¥Êñ∞È°πÁõÆÁä∂ÊÄÅ
        project.status = 'processing'
        project.started_at = datetime.utcnow()
        # üöÄ Êñ∞Êû∂ÊûÑÔºöÁßªÈô§current_segmentÂ≠óÊÆµÔºå‰∏çÂÜçÈúÄË¶ÅËÆæÁΩÆ
        db.commit()
        
        # ËÆ∞ÂΩïÂºÄÂßãÊó•Âøó
        await log_system_event(
            db=db,
            level="info",
            message=f"È°πÁõÆÂºÄÂßãÁîüÊàê: {project.name}",
            module="projects",
            details={
                "project_id": project_id,
                "parallel_tasks": parallel_tasks
            }
        )
        
        return {
            "success": True,
            "message": "È°πÁõÆÁîüÊàêÂ∑≤ÂºÄÂßã",
            "data": {
                "project_id": project_id,
                "status": project.status,
                "parallel_tasks": parallel_tasks
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ÂêØÂä®È°πÁõÆÁîüÊàêÂ§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ÂêØÂä®Â§±Ë¥•: {str(e)}")

@router.post("/{project_id}/pause")
async def pause_project_generation(
    project_id: int,
    db: Session = Depends(get_db)
):
    """ÊöÇÂÅúÈ°πÁõÆÁîüÊàê"""
    try:
        project = db.query(NovelProject).filter(NovelProject.id == project_id).first()
        if not project:
            raise HTTPException(status_code=404, detail="È°πÁõÆ‰∏çÂ≠òÂú®")
        
        if project.status != 'processing':
            raise HTTPException(status_code=400, detail="È°πÁõÆÊú™Âú®Â§ÑÁêÜ‰∏≠")
        
        # Êõ¥Êñ∞È°πÁõÆÁä∂ÊÄÅ
        project.status = 'paused'
        db.commit()
        
        # ËÆ∞ÂΩïÊöÇÂÅúÊó•Âøó
        await log_system_event(
            db=db,
            level="info",
            message=f"È°πÁõÆÊöÇÂÅú: {project.name}",
            module="projects",
            details={"project_id": project_id}
        )
        
        return {
            "success": True,
            "message": "È°πÁõÆÂ∑≤ÊöÇÂÅú",
            "data": {
                "project_id": project_id,
                "status": project.status
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ÊöÇÂÅúÈ°πÁõÆÂ§±Ë¥•: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ÊöÇÂÅúÂ§±Ë¥•: {str(e)}") 