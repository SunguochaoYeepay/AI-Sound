[{"filePath":"D:\\AI-Sound\\platform\\frontend\\src\\components\\ChapterAnalysis.vue","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_segments' is defined but never used.","line":692,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":692,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"chapter-analysis\">\n    <!-- 加载状态 -->\n    <div v-if=\"loading\" class=\"loading-wrapper\">\n      <a-spin size=\"large\" tip=\"加载智能分析结果...\">\n        <div style=\"height: 300px\"></div>\n      </a-spin>\n    </div>\n\n    <!-- 有分析数据 -->\n    <div v-else-if=\"analysisData\" class=\"analysis-content\">\n      <!-- 分析结果tabs -->\n      <div class=\"analysis-tabs\">\n        <a-tabs v-model=\"activeTab\" type=\"card\">\n          <template #rightExtra>\n            <a-space>\n              <!-- 🔥 新增：缓存状态指示器 -->\n              <a-tooltip>\n                <template #title>\n                  <div>\n                    <div>数据来源: {{ getCacheStatusText() }}</div>\n                    <div v-if=\"cacheInfo.user_edited\">用户已编辑</div>\n                    <div>最后更新: {{ getLastUpdateTime() }}</div>\n                  </div>\n                </template>\n                <a-tag :color=\"getCacheStatusColor()\" size=\"small\" style=\"cursor: help\">\n                  {{ getCacheStatusIcon() }} {{ getCacheStatusText() }}\n                </a-tag>\n              </a-tooltip>\n\n              <!-- 🔥 新增：缓存控制按钮 -->\n              <a-dropdown>\n                <template #overlay>\n                  <a-menu>\n                    <a-menu-item @click=\"refreshCache\">\n                      <ReloadOutlined />\n                      强制刷新缓存\n                    </a-menu-item>\n                    <a-menu-item @click=\"clearEditCache\">\n                      <ClearOutlined />\n                      清除编辑缓存\n                    </a-menu-item>\n                    <a-menu-divider />\n                    <a-menu-item @click=\"clearAllCache\" style=\"color: #ff4d4f\">\n                      <DeleteOutlined />\n                      清除所有缓存\n                    </a-menu-item>\n                  </a-menu>\n                </template>\n                <a-button size=\"small\" type=\"text\">\n                  <SettingOutlined />\n                  缓存\n                  <DownOutlined />\n                </a-button>\n              </a-dropdown>\n\n              <a-button\n                type=\"primary\"\n                @click=\"$emit('refresh')\"\n                size=\"small\"\n                :loading=\"preparingChapter\"\n                :disabled=\"isPreparationDisabled\"\n              >\n                🤖 智能准备\n              </a-button>\n\n\n              <a-button\n                type=\"primary\"\n                @click=\"saveChanges\"\n                size=\"small\"\n                :loading=\"saving\"\n              >\n                💾 保存修改\n              </a-button>\n            </a-space>\n          </template>\n\n          <!-- 合成片段tab -->\n          <a-tab-pane key=\"segments\" tab=\"📝 合成片段\">\n            <!-- 🔥 智能检测组件 -->\n            <IntelligentDetector\n              v-if=\"bookId && chapterId\"\n              :book-id=\"bookId\"\n              :chapter-id=\"chapterId\"\n              :segments=\"editableSegments\"\n              :characters=\"allAvailableCharacters\"\n              @segments-updated=\"handleSegmentsUpdate\"\n              @locate-segment=\"locateToSegment\"\n              ref=\"intelligentDetectorRef\"\n              style=\"margin-bottom: 16px; padding: 0 16px\"\n            />\n\n            <!-- 🔥 使用新的合成片段编辑器 -->\n            <SynthesisSegmentEditor\n              :segments=\"editableSegments\"\n              :characters=\"allAvailableCharacters\"\n              :loading=\"loading\"\n              @update:segments=\"handleSegmentsUpdate\"\n              @segment-change=\"handleSegmentChange\"\n              @character-change=\"handleCharacterChange\"\n              @refresh-characters=\"loadBookCharacters\"\n            />\n          </a-tab-pane>\n\n          <!-- JSON数据tab -->\n          <a-tab-pane key=\"json\" tab=\"🔧 JSON数据\">\n            <JsonDataViewer\n              :analysis-data=\"analysisData\"\n              :editable-segments=\"editableSegments\"\n              :editable-characters=\"editableCharacters\"\n              @json-changed=\"handleJsonChanged\"\n              @save-json=\"handleSaveJson\"\n            />\n          </a-tab-pane>\n\n          <!-- 角色信息tab -->\n          <a-tab-pane key=\"characters\" tab=\"🎭 角色信息\">\n            <CharacterInfoViewer\n              :characters=\"editableCharacters\"\n              :segments=\"editableSegments\"\n              :highlighted-character=\"highlightedCharacter\"\n              :testing-voice=\"testingVoice\"\n              :missing-characters-count=\"missingCharactersCount\"\n              :batch-creating=\"batchCreating\"\n              :loading-book-characters=\"loadingBookCharacters\"\n              @highlight-character=\"handleHighlightCharacter\"\n              @export-segments=\"handleExportSegments\"\n              @test-voice=\"handleTestVoice\"\n              @batch-create-characters=\"showBatchCreateModal\"\n              @refresh-character-library=\"refreshCharacterLibrary\"\n            />\n          </a-tab-pane>\n        </a-tabs>\n      </div>\n    </div>\n\n    <!-- 无分析数据 -->\n    <div v-else class=\"no-analysis\">\n      <a-empty description=\"该章节暂无智能分析数据\" :image=\"false\">\n        <div class=\"empty-icon\">🤖</div>\n        <p>请先对章节进行智能准备</p>\n        <a-button type=\"primary\" @click=\"$emit('refresh')\"> 🎭 开始智能准备 </a-button>\n      </a-empty>\n    </div>\n\n    <!-- 🔥 批量创建角色抽屉组件 -->\n    <BatchCreateCharacterDrawer\n      ref=\"batchCreateDrawerRef\"\n      :chapter=\"chapter\"\n      :missing-characters=\"missingCharacters\"\n      v-model:visible=\"batchCreateModalVisible\"\n      v-model:batch-creating=\"batchCreating\"\n      @characters-created=\"handleCharactersCreated\"\n      @refresh-library=\"refreshCharacterLibrary\"\n    />\n\n    <!-- 检测详情模态框已移至IntelligentDetector组件 -->\n\n\n  </div>\n</template>\n\n<script setup>\n  import { ref, computed, watch, onMounted, nextTick } from 'vue'\n  import { message, Modal } from 'ant-design-vue'\n  // import { useAudioPlayerStore } from '@/stores/audioPlayer' // 移除未使用的导入\n  import { charactersAPI } from '@/api'\n  // import draggable from 'vuedraggable' // 移除未使用的导入\n  import SynthesisSegmentEditor from './SynthesisSegmentEditor.vue'\n  import IntelligentDetector from './IntelligentDetector.vue'\n  import BatchCreateCharacterDrawer from './BatchCreateCharacterDrawer.vue'\n\n  import {\n    ReloadOutlined,\n    ClearOutlined,\n    DeleteOutlined,\n    SettingOutlined,\n    DownOutlined\n  } from '@ant-design/icons-vue'\n  // Removed unused imports: smartPrepareAPI, deepAnalyzeAPI\n\n  // 在Vue 3 setup script中，导入的组件可以直接在模板中使用\n\n  const props = defineProps({\n    chapter: {\n      type: Object,\n      default: null\n    },\n    analysisData: {\n      type: Object,\n      default: null\n    },\n    loading: {\n      type: Boolean,\n      default: false\n    },\n    preparingChapter: {\n      type: Boolean,\n      default: false\n    },\n    preparationStatus: {\n      type: Object,\n      default: null\n    }\n  })\n\n  const emit = defineEmits(['refresh', 'save'])\n\n  // const audioStore = useAudioPlayerStore() // 移除未使用的变量\n\n  // 组件注册 - Vue 3版本的vuedraggable直接使用导入的组件\n\n  const activeTab = ref('segments')\n  const saving = ref(false)\n  const hasChanges = ref(false)\n  const highlightedCharacter = ref(null)\n  const testingVoice = ref(null)\n  // 智能检测相关状态\n  // 智能检测相关状态（已移至IntelligentDetector组件）\n  // const detecting = ref(false) - 已移除\n  // const detectionResult = ref(null) - 已移除\n  // const showDetectionDetails = ref(false) // 移除未使用的变量\n  // const applyingFix = ref(false) - 已移除\n\n  // 🔥 新增：缓存状态信息\n  const cacheInfo = ref({\n    data_source: 'synthesis_plan',\n    user_edited: false,\n    cache_status: 'cached',\n    last_updated: null\n  })\n\n  // 可编辑的数据\n  const editableCharacters = ref([])\n  const editableSegments = ref([])\n  const originalData = ref(null)\n\n  // 🔥 新增：加载本书所有角色\n  const loadingBookCharacters = ref(false)\n  const bookCharacters = ref([])\n\n  // 批量创建角色相关状态已移至独立组件\n  const batchCreating = ref(false)\n  \n  // 组件引用\n  const intelligentDetectorRef = ref(null)\n\n\n\n  // Removed unused variables: rawText, segments\n\n\n\n  const loadBookCharacters = async () => {\n    if (!props.chapter?.book_id) {\n      console.warn('缺少书籍ID，无法加载角色')\n      return\n    }\n\n    loadingBookCharacters.value = true\n    try {\n      const response = await charactersAPI.getCharacters({ book_id: props.chapter.book_id })\n      if (response.data?.success && response.data.data) {\n        bookCharacters.value = response.data.data.map((char) => ({\n          ...char,\n          is_voice_configured: char.is_voice_configured || false,\n          avatarUrl: char.avatarUrl || null\n        }))\n        console.log('本书角色加载成功:', bookCharacters.value.length, '个角色')\n      } else {\n        console.warn('加载角色失败:', response.data?.message)\n      }\n    } catch (error) {\n      console.error('加载角色失败:', error)\n    } finally {\n      loadingBookCharacters.value = false\n    }\n  }\n\n  // 🔥 新增：获取不在角色配音库中的角色\n  const missingCharacters = computed(() => {\n    return editableCharacters.value.filter((char) => !char.in_character_library)\n  })\n\n  // 🔥 新增：待添加角色数量\n  const missingCharactersCount = computed(() => {\n    return missingCharacters.value.length\n  })\n\n  // 移除未使用的计算属性：hasAnalysisData\n\n  // 语音类型选项、角色表格列配置、表格行选择配置已移至BatchCreateCharacterDrawer组件\n\n  // 🔥 新增：强制刷新方法\n  const forceRefreshSegments = async () => {\n    console.log('[角色分析] 强制刷新segments数据')\n    await nextTick()\n    // 触发响应式更新\n    const temp = [...editableSegments.value]\n    editableSegments.value = []\n    await nextTick()\n    editableSegments.value = temp\n    console.log('[角色分析] 强制刷新完成，当前segments数量:', editableSegments.value.length)\n  }\n\n  // Removed unused computed property: processingInfo\n\n  // 是否禁用准备按钮\n  const isPreparationDisabled = computed(() => {\n    return (\n      props.preparingChapter ||\n      props.preparationStatus?.analysis_status === 'processing' ||\n      props.preparationStatus?.synthesis_status === 'processing'\n    )\n  })\n\n  // 🔥 简化：初始化可编辑数据，直接使用JSON中的角色信息\n  const initEditableData = async () => {\n    if (!props.analysisData?.synthesis_json) {\n      console.warn('[角色分析] 没有有效的分析结果数据')\n      return\n    }\n\n    const synthesisJson = props.analysisData.synthesis_json\n\n    try {\n      // 🔥 优化：智能提取角色信息，优先使用characters字段，fallback到synthesis_plan\n      console.log('[角色分析] 开始提取角色信息')\n\n      if (synthesisJson.characters && synthesisJson.characters.length > 0) {\n        // 如果有characters字段，直接使用\n        console.log('[角色分析] 使用characters字段')\n        editableCharacters.value = synthesisJson.characters.map((char) => ({\n          ...char,\n          character_id: char.character_id || null,\n          voice_id: char.voice_id || '',\n          voice_name: char.voice_name || char.name || '未分配',\n          voice_type: char.voice_type || (char.name === '旁白' ? 'narrator' : 'neutral'),\n          count: char.count || 0,\n          in_character_library: char.in_character_library || false,\n          is_voice_configured: char.is_voice_configured || false,\n          avatarUrl: char.avatarUrl || null\n        }))\n      } else {\n        // 如果没有characters字段，从synthesis_plan中提取\n        console.log('[角色分析] 从synthesis_plan中提取角色信息')\n        const segments = synthesisJson.synthesis_plan || []\n        const characterMap = new Map()\n\n        // 统计每个角色的出现次数和信息\n        segments.forEach((segment) => {\n          // 🔥 修复：使用正确的说话人字段映射，支持多种可能的字段名\n          const speaker = segment.speaker || segment.speaker_name || segment.character_name || segment.character || '未知'\n          if (!characterMap.has(speaker)) {\n            characterMap.set(speaker, {\n              name: speaker,\n              character_id: segment.character_id || null,\n              voice_id: segment.voice_id || '',\n              voice_name: segment.voice_name || speaker,\n              voice_type: speaker === '旁白' ? 'narrator' : 'neutral',\n              count: 0,\n              in_character_library: segment.character_id ? true : false,\n              is_voice_configured: segment.voice_id ? true : false,\n              avatarUrl: null\n            })\n          }\n          characterMap.get(speaker).count++\n        })\n\n        // 转换为数组\n        editableCharacters.value = Array.from(characterMap.values())\n      }\n\n      // 对角色按出现次数排序\n      editableCharacters.value.sort((a, b) => (b.count || 0) - (a.count || 0))\n\n      console.log('[角色分析] 最终角色信息:', editableCharacters.value)\n\n      // 初始化可编辑的合成计划，确保包含所有必要字段\n      const segments = synthesisJson.synthesis_plan || []\n      editableSegments.value = segments.map((segment, index) => {\n        // 🔥 调试日志：打印原始segment数据\n        console.log(`[字段映射调试] 原始segment ${index}:`, {\n          segment_id: segment.segment_id,\n          speaker: segment.speaker,\n          text: segment.text ? segment.text.substring(0, 50) + '...' : 'NO_TEXT',\n          voice_id: segment.voice_id,\n          character_id: segment.character_id\n        })\n\n        // 🔥 修复：确保所有必要字段都正确映射\n        const mappedSegment = {\n          ...segment,\n          // 确保ID字段正确\n          id: segment.id || segment.segment_id || `segment_${index}_${Date.now()}`,\n          segment_id: segment.segment_id || (index + 1),\n          chapter_id: segment.chapter_id || props.chapter?.id || null,\n          chapter_number: segment.chapter_number || props.chapter?.number || 1,\n          // 🔥 关键修复：确保speaker和text字段正确显示\n          speaker: segment.speaker || '未知说话人',\n          text: segment.text || '',\n          \n          // 🔥 强制响应式更新\n          _forceUpdate: Date.now(),\n          \n          // 语音配置字段\n          character_id: segment.character_id || null,\n          voice_id: segment.voice_id || '',\n          voice_name: segment.voice_name || '未分配',\n          \n          // 其他必要字段\n          text_type: segment.text_type || 'narration',\n          confidence: segment.confidence || 0.9,\n          detection_rule: segment.detection_rule || 'manual_input',\n          timeStep: segment.timeStep || 32,\n          pWeight: segment.pWeight || 2,\n          tWeight: segment.tWeight || 3,\n          narrator_mode: segment.narrator_mode !== undefined ? segment.narrator_mode : true,\n          skip_ai_analysis: segment.skip_ai_analysis !== undefined ? segment.skip_ai_analysis : false\n        }\n\n        // 🔥 验证关键字段\n        if (!mappedSegment.text) {\n          console.warn(`⚠️ 段落 ${index} 缺少文本内容:`, segment)\n        }\n        if (!mappedSegment.speaker || mappedSegment.speaker === '未知说话人') {\n          console.warn(`⚠️ 段落 ${index} 缺少说话人信息:`, segment)\n        }\n\n        console.log(`[字段映射调试] 映射后segment ${index}:`, {\n          segment_id: mappedSegment.segment_id,\n          speaker: mappedSegment.speaker,\n          text: mappedSegment.text.substring(0, 50) + '...',\n          character_id: mappedSegment.character_id,\n          voice_id: mappedSegment.voice_id\n        })\n\n        return mappedSegment\n      })\n\n      // 保存原始数据用于比较变化\n      originalData.value = JSON.parse(\n        JSON.stringify({\n          characters: editableCharacters.value,\n          segments: editableSegments.value\n        })\n      )\n\n      console.log('[角色分析] 数据初始化完成')\n      \n      // 🔥 修复：重置hasChanges状态，避免保存按钮被禁用\n      hasChanges.value = false\n      \n      // 🔥 强制Vue重新渲染\n      await nextTick()\n      console.log('[角色分析] 强制重新渲染完成')\n      \n      // 🔥 强制刷新方法确保数据正确显示\n      await forceRefreshSegments()\n    } catch (error) {\n      console.error('[角色分析] 初始化数据失败:', error)\n      message.error('初始化角色分析数据失败')\n    }\n  }\n\n  // 🔥 修复：监听分析数据变化，确保数据正确初始化\n  watch(\n    () => props.analysisData,\n    async (newData) => {\n      console.log('[角色分析] 监听到analysisData变化:', newData)\n      if (newData) {\n        console.log('[角色分析] 开始初始化可编辑数据...')\n        await initEditableData()\n        console.log('[角色分析] 初始化完成，当前角色数:', editableCharacters.value.length)\n      } else {\n        console.log('[角色分析] analysisData为空，清空编辑数据')\n        editableCharacters.value = []\n        editableSegments.value = []\n      }\n    },\n    { immediate: true, deep: true }\n  )\n\n  // 🔥 新增：当没有分析数据但有角色库数据时，创建基础角色\n  watch(\n    () => [props.analysisData, bookCharacters.value],\n    ([analysisData, bookChars]) => {\n      // 如果没有分析数据但有角色库数据，且当前editableCharacters为空\n      if (!analysisData && bookChars.length > 0 && editableCharacters.value.length === 0) {\n        console.log('[角色分析] 基于角色库创建基础角色选项')\n        editableCharacters.value = bookChars.map(char => ({\n          name: char.name,\n          character_id: char.id,\n          voice_id: char.id.toString(),\n          voice_name: char.name,\n          voice_type: char.voice_type || 'neutral',\n          count: 0,\n          in_character_library: true,\n          is_voice_configured: char.is_voice_configured || false,\n          avatarUrl: char.avatarUrl || null\n        }))\n        console.log('[角色分析] 基础角色创建完成:', editableCharacters.value.length, '个角色')\n      }\n    },\n    { deep: true }\n  )\n\n  // 🔥 新增：监听章节变化，自动加载本书角色\n  watch(\n    () => props.chapter,\n    (newChapter) => {\n      if (newChapter?.book_id) {\n        loadBookCharacters()\n      }\n    },\n    { immediate: true }\n  )\n\n  // 🔥 新增：页面加载时初始化\n  onMounted(() => {\n    if (props.chapter?.book_id) {\n      loadBookCharacters()\n    }\n  })\n\n  // 批量创建角色相关方法已移至BatchCreateCharacterDrawer组件\n  \n  const refreshCharacterLibrary = async () => {\n    await loadBookCharacters()\n    // 重新检查角色配音库关联状态\n    await initEditableData()\n    message.success('角色配音库已刷新')\n  }\n\n  // 移除未使用的函数：updateSynthesisPlanWithNewCharacterNames\n\n  // 标记为已修改\n  const markChanged = () => {\n    hasChanges.value = true\n  }\n\n\n\n  // 🔥 修复缺失字段的段落 - 保持原有segment_id不变\n  const fixMissingFields = (_segments) => {\n    // 获取所有已有的segment_id\n    const existingSegmentIds = _segments.map((s) => s.segment_id).filter((id) => id)\n    const maxSegmentId = Math.max(...existingSegmentIds, 0)\n\n    let newSegmentCounter = 1\n\n    return _segments.map((segment, index) => {\n      // 🔥 关键修复：只修复缺失字段，保持原有segment_id不变\n      if (!segment.segment_id || !segment.chapter_id || !segment.text_type) {\n        console.log(`[修复段落] 修复段落 ${index + 1} 的缺失字段`)\n\n        // 只有在segment_id真正缺失时才分配新的ID\n        let newSegmentId = segment.segment_id\n        if (!newSegmentId) {\n          // 为新段落分配新的segment_id，确保不重复\n          newSegmentId = maxSegmentId + newSegmentCounter\n          newSegmentCounter++\n        }\n\n        return {\n          ...segment,\n          segment_id: newSegmentId,\n          chapter_id: segment.chapter_id || props.chapter?.id || null,\n          chapter_number: segment.chapter_number || props.chapter?.number || 1,\n          text_type: segment.text_type || 'narration',\n          confidence: segment.confidence || 0.9,\n          detection_rule: segment.detection_rule || 'manual_input',\n          timeStep: segment.timeStep || 32,\n          pWeight: segment.pWeight || 2,\n          tWeight: segment.tWeight || 3,\n          narrator_mode: segment.narrator_mode !== undefined ? segment.narrator_mode : true,\n          skip_ai_analysis:\n            segment.skip_ai_analysis !== undefined ? segment.skip_ai_analysis : false,\n          character_id: segment.character_id || null,\n          voice_id: segment.voice_id || ''\n        }\n      }\n      // 🔥 关键：对于已有完整字段的段落，保持原样不变\n      return segment\n    })\n  }\n\n  // 保存修改\n  const saveChanges = async () => {\n    // 🔥 修复：即使hasChanges为false也允许保存，确保按钮有响应\n    if (!hasChanges.value) {\n      console.log('📝 没有检测到数据变化，但仍允许保存')\n    }\n\n    saving.value = true\n    try {\n      console.log('🚀 开始保存智能分析数据...')\n      \n      // 🔥 修复缺失字段的段落\n      const fixedSegments = fixMissingFields(editableSegments.value)\n\n      // 🔥 修复：同步更新total_segments字段\n      const currentTotalSegments = fixedSegments.length\n      console.log('💾 保存时更新total_segments:', {\n        原始total_segments: props.analysisData.synthesis_json.project_info?.total_segments,\n        实际段落数量: currentTotalSegments\n      })\n\n      const updatedData = {\n        ...props.analysisData,\n        synthesis_json: {\n          ...props.analysisData.synthesis_json,\n          project_info: {\n            ...props.analysisData.synthesis_json.project_info,\n            total_segments: currentTotalSegments\n          },\n          processing_info: {\n            ...props.analysisData.synthesis_json.processing_info,\n            total_segments: currentTotalSegments\n          },\n          characters: editableCharacters.value,\n          synthesis_plan: fixedSegments\n        }\n      }\n\n      console.log('📤 发送保存事件到父组件:', {\n        chapterId: props.chapter?.id,\n        dataLength: JSON.stringify(updatedData).length,\n        segmentsCount: fixedSegments.length,\n        charactersCount: editableCharacters.value.length,\n        hasChanges: hasChanges.value\n      })\n\n      // 🔥 修复：强制触发保存事件\n      emit('save', updatedData)\n      \n      // 🔥 修复：重置变更状态\n      hasChanges.value = false\n      message.success('保存成功！数据已更新到服务器')\n    } catch (error) {\n      console.error('❌ 保存失败:', error)\n      message.error('保存失败: ' + (error.message || '未知错误'))\n    } finally {\n      saving.value = false\n    }\n  }\n\n\n\n\n\n  // 移除未使用的函数：getJsonPreview\n\n  // 移除未使用的函数：copyJson, handleBatchCreateCharacters, getCharacterColor\n\n\n\n\n\n\n\n\n\n\n  // 🔥 新增：合成片段编辑器相关方法\n  // 合并所有可用角色\n  const allAvailableCharacters = computed(() => {\n    const combined = [...editableCharacters.value, ...bookCharacters.value]\n    // 去重，优先保留editableCharacters中的角色\n    const uniqueCharacters = []\n    const seen = new Set()\n    \n    for (const char of combined) {\n      if (!seen.has(char.name)) {\n        seen.add(char.name)\n        uniqueCharacters.push(char)\n      }\n    }\n    \n    return uniqueCharacters\n  })\n\n  // 处理片段更新\n  const handleSegmentsUpdate = (_segments) => {\n    console.log('[ChapterAnalysis] 片段更新:', _segments.length, '个片段')\n    editableSegments.value = _segments\n    markChanged()\n  }\n\n  // 处理片段变化\n  const handleSegmentChange = (_segments) => {\n    console.log('[ChapterAnalysis] 片段内容变化')\n    markChanged()\n  }\n\n  // 处理角色变化\n  const handleCharacterChange = (segment, speaker) => {\n    console.log('[ChapterAnalysis] 角色变化:', segment.id, speaker)\n    markChanged()\n  }\n\n  // 定位到指定片段\n  const locateToSegment = (segmentIndex) => {\n    console.log('[ChapterAnalysis] 定位片段:', segmentIndex)\n    // 可以在这里添加滚动到指定片段的逻辑\n    // 例如：滚动到对应的DOM元素\n    const segmentElement = document.querySelector(`[data-segment-index=\"${segmentIndex}\"]`)\n    if (segmentElement) {\n      segmentElement.scrollIntoView({ behavior: 'smooth', block: 'center' })\n      // 添加高亮效果\n      segmentElement.classList.add('segment-highlighted')\n      setTimeout(() => {\n        segmentElement.classList.remove('segment-highlighted')\n      }, 3000)\n    }\n  }\n\n  // 🔥 新增：缓存控制方法\n  // 获取缓存状态文本\n  const getCacheStatusText = () => {\n    switch (cacheInfo.value.data_source) {\n      case 'final_config':\n        return '用户编辑'\n      case 'synthesis_plan':\n        return '智能准备'\n      default:\n        return '未知'\n    }\n  }\n\n  // 获取缓存状态颜色\n  const getCacheStatusColor = () => {\n    if (cacheInfo.value.user_edited) return 'purple'\n    if (cacheInfo.value.cache_status === 'fresh') return 'green'\n    return 'blue'\n  }\n\n  // 获取缓存状态图标\n  const getCacheStatusIcon = () => {\n    if (cacheInfo.value.user_edited) return '✏️'\n    if (cacheInfo.value.cache_status === 'fresh') return '🔄'\n    return '💾'\n  }\n\n  // 获取最后更新时间\n  const getLastUpdateTime = () => {\n    if (!cacheInfo.value.last_updated) return '未知'\n    try {\n      const date = new Date(cacheInfo.value.last_updated)\n      return date.toLocaleString('zh-CN')\n    } catch {\n      return '未知'\n    }\n  }\n\n  // 强制刷新缓存\n  const refreshCache = async () => {\n    try {\n      message.loading('正在刷新缓存...', 0)\n      // 发送带有force_refresh参数的请求\n      emit('refresh', { force_refresh: true })\n      message.destroy()\n      message.success('缓存已刷新，将显示最新数据')\n    } catch (error) {\n      message.destroy()\n      message.error('刷新缓存失败')\n      console.error('刷新缓存失败:', error)\n    }\n  }\n\n  // 清除编辑缓存\n  const clearEditCache = async () => {\n    try {\n      if (!props.chapter?.id) {\n        message.error('缺少章节信息')\n        return\n      }\n\n      message.loading('正在清除编辑缓存...', 0)\n\n      // 调用API清除final_config缓存\n      await charactersAPI.clearPreparationCache(props.chapter.id, 'final_config')\n\n      message.destroy()\n      message.success('编辑缓存已清除，将显示智能准备结果')\n\n      // 刷新数据\n      emit('refresh', { force_refresh: true })\n    } catch (error) {\n      message.destroy()\n      message.error('清除编辑缓存失败')\n      console.error('清除编辑缓存失败:', error)\n    }\n  }\n\n  // 清除所有缓存\n  const clearAllCache = async () => {\n    try {\n      if (!props.chapter?.id) {\n        message.error('缺少章节信息')\n        return\n      }\n\n      // 确认操作\n      const confirmed = await new Promise((resolve) => {\n        Modal.confirm({\n          title: '确认清除所有缓存',\n          content: '这将删除所有智能准备结果，需要重新进行智能准备。确定继续吗？',\n          okText: '确认清除',\n          cancelText: '取消',\n          okButtonProps: { danger: true },\n          onOk: () => resolve(true),\n          onCancel: () => resolve(false)\n        })\n      })\n\n      if (!confirmed) return\n\n      message.loading('正在清除所有缓存...', 0)\n\n      // 调用API清除所有缓存\n      await charactersAPI.clearPreparationCache(props.chapter.id, 'all')\n\n      message.destroy()\n      message.success('所有缓存已清除，请重新进行智能准备')\n\n      // 刷新数据\n      emit('refresh')\n    } catch (error) {\n      message.destroy()\n      message.error('清除所有缓存失败')\n      console.error('清除所有缓存失败:', error)\n    }\n  }\n\n  // 移除未使用的函数：addNewSegment, insertSegmentAfter, deleteSegment\n\n  // 移除未使用的函数以修复ESLint错误\n\n  // 智能检测相关方法\n  // 智能检测方法已移至IntelligentDetector组件\n\n  // 智能检测相关方法已移至IntelligentDetector组件\n\n  // jumpToSegment函数已移除（未使用）\n\n  // 🔥 新增：角色相关事件处理方法\n  const handleHighlightCharacter = (characterName) => {\n    if (highlightedCharacter.value === characterName) {\n      highlightedCharacter.value = null\n      message.info('取消高亮')\n    } else {\n      highlightedCharacter.value = characterName\n      message.info(`高亮角色\"${characterName}\"的片段`)\n      // 切换到片段tab\n      activeTab.value = 'segments'\n    }\n  }\n\n  const handleExportSegments = (characterName) => {\n    const characterSegments = editableSegments.value\n      .filter((segment) => segment.speaker === characterName)\n      .map((segment, index) => `${index + 1}. ${segment.text}`)\n      .join('\\n\\n')\n\n    if (characterSegments) {\n      const blob = new Blob([`角色\"${characterName}\"的片段：\\n\\n${characterSegments}`], {\n        type: 'text/plain;charset=utf-8'\n      })\n      const url = URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `第${props.chapter?.number}章_${characterName}_片段.txt`\n      document.body.appendChild(link)\n      link.click()\n      document.body.removeChild(link)\n      URL.revokeObjectURL(url)\n      message.success(`角色\"${characterName}\"的片段导出成功`)\n    } else {\n      message.warning(`角色\"${characterName}\"没有片段`)\n    }\n  }\n\n  const handleTestVoice = (characterName) => {\n    testingVoice.value = characterName\n    message.info(`正在测试角色\"${characterName}\"的语音...`)\n    \n    // 模拟语音测试过程\n    setTimeout(() => {\n      testingVoice.value = null\n      message.success(`角色\"${characterName}\"的语音测试完成`)\n    }, 2000)\n  }\n\n  // 🔥 新增：保存JSON数据的方法\n  const handleSaveJson = () => {\n    try {\n      const jsonData = {\n        chapter: props.chapter,\n        segments: editableSegments.value,\n        characters: editableCharacters.value,\n        synthesis_json: props.analysisData?.synthesis_json\n      }\n      \n      const blob = new Blob([JSON.stringify(jsonData, null, 2)], {\n        type: 'application/json;charset=utf-8'\n      })\n      const url = URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `第${props.chapter?.number}章_分析数据.json`\n      document.body.appendChild(link)\n      link.click()\n      document.body.removeChild(link)\n      URL.revokeObjectURL(url)\n      message.success('JSON数据导出成功')\n    } catch (error) {\n      console.error('导出JSON失败:', error)\n      message.error('导出JSON数据失败')\n    }\n  }\n\n  // 🔥 新增：批量创建角色模态框的可见性\n  const batchCreateModalVisible = ref(false)\n\n  // 🔥 新增：显示批量创建角色模态框的处理函数\n  const showBatchCreateModal = () => {\n    batchCreateModalVisible.value = true\n  }\n\n  // 🔥 新增：计算属性 bookId 和 chapterId\n  const bookId = computed(() => props.chapter?.book_id)\n  const chapterId = computed(() => props.chapter?.id)\n\n  // 🔥 新增：处理 JSON 数据变化的方法\n  const handleJsonChanged = (data) => {\n    console.log('[ChapterAnalysis] JSON 数据已更改')\n    if (data.segments) {\n      editableSegments.value = data.segments\n    }\n    if (data.characters) {\n      editableCharacters.value = data.characters\n    }\n    markChanged()\n    message.success('JSON 数据已更新')\n  }\n\n  // 🔥 新增：处理角色创建完成的方法\n  const handleCharactersCreated = (createdCharacters) => {\n    console.log('[ChapterAnalysis] 角色创建完成:', createdCharacters)\n    // 重新加载本书角色\n    loadBookCharacters()\n    // 更新角色信息\n    editableCharacters.value = editableCharacters.value.map(char => {\n      const created = createdCharacters.find(c => c.name === char.name)\n      if (created) {\n        return {\n          ...char,\n          character_id: created.character_id,\n          in_character_library: true,\n          is_voice_configured: created.is_voice_configured || false\n        }\n      }\n      return char\n    })\n    markChanged()\n    message.success(`成功创建 ${createdCharacters.length} 个角色`)\n  }\n\n  // 重复定义已删除，使用前面的refreshCharacterLibrary函数\n</script>\n\n<style scoped>\n  .chapter-analysis {\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n  }\n\n  .loading-wrapper {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n\n  .analysis-content {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n  }\n\n  .analysis-toolbar {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 12px 16px;\n  }\n\n  .analysis-tabs {\n    flex: 1;\n    overflow: hidden;\n\n    :deep(.ant-tabs) {\n\n      height: 100%;\n      display: flex;\n      flex-direction: column;\n\n      .ant-tabs-nav {\n        background: var(--component-background);\n        border-bottom: 1px solid var(--border-color-base);\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n\n        &::before {\n          display: none;\n        }\n\n        .ant-tabs-nav-wrap {\n          flex: 1;\n        }\n\n        .ant-tabs-extra-content {\n          margin-left: 16px;\n        }\n      }\n    }\n\n    :deep(.ant-tabs-content-holder) {\n      flex: 1;\n      overflow: auto;\n    }\n  }\n\n  .segments-view {\n    padding: 16px;\n    height: 100%;\n    overflow-y: auto;\n  }\n\n  .segments-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n  }\n\n  .segments-header h4 {\n    margin: 0;\n    color: #1f2937;\n  }\n\n  .segment-count {\n    font-size: 12px;\n    color: #6b7280;\n  }\n\n  /* 段落编辑器样式 */\n  .segments-editor {\n    border: 1px solid #e8e8e8;\n    border-radius: 8px;\n    overflow: hidden;\n  }\n\n  .editor-header {\n    padding: 12px 16px;\n    border-bottom: 1px solid #e8e8e8;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  .editor-header h4 {\n    margin: 0;\n    font-size: 14px;\n    color: #333;\n  }\n\n  .editor-controls {\n    display: flex;\n    gap: 8px;\n  }\n\n  /* .segments-list 样式已移除，使用默认样式 */\n\n  .segment-item {\n    padding: 12px 16px;\n    border-bottom: 1px solid #f0f0f0;\n    transition: all 0.2s ease;\n  }\n\n  .segment-item:hover {\n    background: #fafafa;\n  }\n\n  .segment-item:last-child {\n    border-bottom: none;\n  }\n\n  .segment-header {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 8px;\n  }\n\n  .segment-index {\n    font-weight: 500;\n    color: #666;\n    min-width: 40px;\n  }\n\n  .segment-actions {\n    display: flex;\n    gap: 4px;\n    margin-left: auto;\n    opacity: 0;\n    transition: opacity 0.2s ease;\n  }\n\n  .segment-item:hover .segment-actions {\n    opacity: 1;\n  }\n\n  .character-option {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    width: 100%;\n  }\n\n  .char-name {\n    flex: 1;\n    margin-right: 8px;\n  }\n\n  /* 段落高亮样式 */\n  .segment-highlighted {\n    background: #e6f7ff;\n    border-left: 3px solid #1890ff;\n  }\n\n  .segment-dimmed {\n    opacity: 0.5;\n  }\n\n  /* 拖拽排序样式 */\n  .segment-ghost {\n    opacity: 0.5;\n    background: #f0f0f0;\n    border: 2px dashed #d9d9d9;\n  }\n\n  .segment-chosen {\n    background: #e6f7ff;\n    border-left: 3px solid #1890ff;\n  }\n\n  .segment-drag {\n    background: #fff;\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);\n    border: 1px solid #1890ff;\n    border-radius: 4px;\n    transform: rotate(5deg);\n  }\n\n  /* 响应式设计 */\n  @media (max-width: 768px) {\n    .editor-header {\n      flex-direction: column;\n      gap: 8px;\n      align-items: flex-start;\n    }\n\n    .editor-controls {\n      width: 100%;\n      justify-content: flex-end;\n    }\n\n    .segment-header {\n      flex-wrap: wrap;\n      gap: 4px;\n    }\n\n    .segment-actions {\n      opacity: 1; /* 移动端始终显示 */\n    }\n  }\n\n  .segment-content {\n    margin-top: 8px;\n  }\n\n  .json-view {\n    padding: 16px;\n    height: 100%;\n    overflow-y: auto;\n  }\n\n  .json-header {\n    margin-bottom: 16px;\n    padding: 8px 0;\n    border-bottom: 1px solid #f0f0f0;\n  }\n\n  .json-editor {\n    height: calc(100% - 100px);\n  }\n\n  .json-display {\n    font-family: 'Courier New', monospace;\n    font-size: 12px;\n    line-height: 1.4;\n    background: #f8fafc;\n    border: 1px solid #e5e7eb;\n    border-radius: 6px;\n    resize: none;\n    height: 100%;\n  }\n\n  .json-display.editable {\n    border-color: #40a9ff;\n    box-shadow: 0 0 0 2px rgba(64, 169, 255, 0.2);\n    background-color: #fafafa;\n  }\n\n  .json-display.editable:focus {\n    border-color: #40a9ff;\n    box-shadow: 0 0 0 2px rgba(64, 169, 255, 0.3);\n  }\n\n  .characters-view {\n    padding: 16px;\n    height: 100%;\n    overflow-y: auto;\n  }\n\n  .characters-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n  }\n\n  .characters-header h4 {\n    margin: 0;\n    color: #1f2937;\n  }\n\n  .character-stats {\n    font-size: 12px;\n    color: #6b7280;\n  }\n\n  .characters-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 16px;\n    margin-top: 16px;\n  }\n\n  .character-card {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    padding: 16px;\n    background: #fff;\n    transition: all 0.2s;\n    position: relative;\n    overflow: hidden;\n  }\n\n  .character-card:hover {\n    border-color: #3b82f6;\n    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1);\n  }\n\n  .character-header {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    margin-bottom: 12px;\n  }\n\n  .character-avatar {\n    flex-shrink: 0;\n  }\n\n  .character-info {\n    flex: 1;\n    min-width: 0;\n  }\n\n  .character-name {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 4px;\n  }\n\n  .name-text {\n    font-size: 16px;\n    font-weight: 600;\n    color: #1f2937;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  .character-rank {\n    font-size: 12px;\n    color: #6b7280;\n    flex-shrink: 0;\n  }\n\n  .character-tags {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 4px;\n    margin-top: 4px;\n  }\n\n  .character-details {\n    margin-top: 12px;\n  }\n\n  .character-actions {\n    margin-top: 12px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    gap: 8px;\n  }\n\n  .no-analysis {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 100%;\n    text-align: center;\n  }\n\n  .empty-icon {\n    font-size: 48px;\n    margin-bottom: 16px;\n    opacity: 0.5;\n  }\n\n  .no-analysis p {\n    color: #6b7280;\n    margin: 8px 0 16px 0;\n  }\n\n  /* 🔥 新增：角色头部布局样式 */\n  .characters-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    margin-bottom: 20px;\n    padding-bottom: 12px;\n    border-bottom: 1px solid #f0f0f0;\n  }\n\n  .characters-title {\n    flex: 1;\n  }\n\n  .characters-actions {\n    flex-shrink: 0;\n  }\n\n  /* 🔥 新增：批量创建抽屉样式 */\n  .batch-create-content {\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n\n  .batch-create-body {\n    flex: 1;\n    padding-right: 8px;\n  }\n\n  .selection-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n  }\n\n  .selection-header h4 {\n    margin: 0;\n  }\n\n  .characters-grid-batch {\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 12px;\n    max-height: 400px;\n    overflow-y: auto;\n    padding: 8px;\n    border: 1px solid #f0f0f0;\n    border-radius: 6px;\n  }\n\n  .character-batch-item {\n    border: 1px solid #e8e8e8;\n    border-radius: 8px;\n    padding: 12px;\n    transition: all 0.2s ease;\n  }\n\n  .character-batch-item:hover {\n    border-color: #1890ff;\n    background-color: #f6f9ff;\n  }\n\n  .character-batch-info {\n    width: 100%;\n  }\n\n  .character-batch-header {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n  }\n\n  .character-batch-details {\n    flex: 1;\n  }\n\n  .character-batch-details .character-name {\n    font-weight: 600;\n    font-size: 14px;\n    margin-bottom: 4px;\n  }\n\n  .character-batch-details .character-meta {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    font-size: 12px;\n    color: #666;\n  }\n\n  .character-count {\n    background: #f0f0f0;\n    padding: 2px 6px;\n    border-radius: 4px;\n    font-size: 11px;\n  }\n\n  .voice-config-form {\n    background: #fafafa;\n    padding: 12px;\n    border-radius: 6px;\n    margin-top: 8px;\n  }\n\n  .batch-summary {\n    margin-top: 16px;\n  }\n\n  .summary-info h4 {\n    margin: 0 0 8px 0;\n    color: #1890ff;\n  }\n\n  .summary-info p {\n    margin: 4px 0;\n  }\n\n  .summary-note {\n    color: #52c41a;\n    font-size: 13px;\n    background: #f6ffed;\n    padding: 8px;\n    border-radius: 4px;\n    border-left: 3px solid #52c41a;\n  }\n\n  /* 🔥 新增：音频上传样式 */\n  .audio-upload-section {\n    margin-top: 8px;\n  }\n\n  .upload-tips {\n    margin-top: 8px;\n  }\n\n  .upload-tips .ant-alert {\n    border-radius: 4px;\n  }\n\n  /* 优化抽屉footer */\n  .drawer-footer {\n    box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.05);\n  }\n\n  /* 文件上传按钮样式 */\n  .audio-upload-section .ant-upload {\n    display: block;\n    width: 100%;\n  }\n\n  .audio-upload-section .ant-btn {\n    height: 32px;\n    font-size: 12px;\n  }\n\n  /* 🔥 新增：角色表格样式 */\n  .characters-table {\n    margin-top: 16px;\n  }\n\n  .character-name-cell .name {\n    font-weight: 500;\n    margin-bottom: 4px;\n  }\n\n  .character-name-cell .meta {\n    display: flex;\n    gap: 8px;\n  }\n\n  .description-cell {\n    max-width: 200px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  /* 🔥 新增：统一音频配置样式 */\n  .audio-config-content {\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n\n  .audio-config-body {\n    flex: 1;\n    padding-right: 8px;\n  }\n\n  .config-description {\n    color: #666;\n    font-size: 14px;\n    margin-bottom: 20px;\n    line-height: 1.6;\n  }\n\n  .unified-audio-upload {\n    margin-top: 12px;\n  }\n\n  .unified-audio-upload .ant-btn {\n    border-style: dashed;\n    color: #666;\n  }\n\n  .unified-audio-upload .ant-btn:hover {\n    border-color: #1890ff;\n    color: #1890ff;\n  }\n\n  /* 智能检测样式已移至IntelligentDetector组件 */\n\n  /* 空文本警告样式 */\n  .empty-text-warning {\n    border-color: #ff7875 !important;\n    background-color: #fff2f0 !important;\n  }\n\n  .empty-text-warning:focus {\n    border-color: #ff7875 !important;\n    box-shadow: 0 0 0 2px rgba(255, 120, 117, 0.2) !important;\n  }\n\n  .empty-text-hint {\n    margin-top: 8px;\n    padding: 8px 12px;\n    background: #fff7e6;\n    border: 1px solid #ffd591;\n    border-radius: 6px;\n    font-size: 12px;\n    color: #d46b08;\n    line-height: 1.5;\n  }\n\n  .empty-text-hint br {\n    margin: 2px 0;\n  }\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]